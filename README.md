نام و نام خانوادگی: امیرمحمد درخشنده - شماره دانشجویی: ۴۰۰۱۰۱۱۵۳

نیمسال تحصیلی دوم سال ۱۴۰۳-۰۴ - تمرین دستگرمی سری دوم
نام استاد درس: استاد پورسلطانی

## گام اول: ساخت پروژه

در گام اول، با استفاده از دستور

```
npx create-react-app .
```

## گام دوم: ساخت Template اجزای اصلی صفحه

می‌توانیم یک پروژه ری‌اکت بسازیم. بعد از انجام این عمل، برای هر کدام از باکس های پروژه(شامل header، اسلایدبار و ...)، نیاز است تا یک فایل جداگانه بسازیم(در نظر داشته باشید که اگر هر component، به صورت مجزا و در فایل جداگانه ای ساخته شود، ظاهر و شمایل پروژه، بسیار خواناتر و واضح‌تر خواهد بود). از آن‌جایی که چهار component اصلی(header, canvas, slidebar, counterBox) داریم، برای هر کدام، یک فایل js به همراه یک فایل استایل می‌سازیم(البته در رابطه با استایل ها، می‌توان همگی را در یک فایل قرار داد، اما در این پروژه، من فایل های استایل را نیز جداگانه ساختم، چرا که اجزای چندان زیادی نداریم و به لحاظ شلوغی پروژه از دیدگاه تعداد فایل ها، دچار مشکل نخواهیم شد).

در نهایت، داخل فایل js هر کدام، باکس مورد نظر را(در قالب یک div) می‌سازیم و استایل آن‌را(که مهم‌ترین قسمت استایل، رنگ و فواصل از حاشیه‌ها هستند) در فایل متناظر، وارد می‌کنیم.
![نمونه اولیه از اجزای صفحه](images/box%20templates.png)

## گام سوم: طراحی هدر

در گام سوم، به طراحی باکس هدر متناسب با نیازمندی های پروژه خواهیم پرداخت. سه عنوان اصلی برای این باکس مورد نیاز است: نام فایل، دکمه import و دکمه export. برای طراحی این سه عنوان، داخل فایل header.js، تغییرات را می‌توان ایجاد کرد. به منظور ساخت عنوان، از یک div با نوشته فرضی و اولیه Painting Title استفاده می‌کنیم. همچنین برای دکمه ها، از Button با کلاس btn استفاده می‌کنیم. توجه داشته باشید که دکمه هارا در یک باکس با نام کلاس btn-group قرار می‌دهیم و در استایل این باکس، flex-direction را با columns، مقداردهی می‌کنیم تا دکمه ها، زیر هم قرار بگیرند. همچنین در تنظیمات استایل، دکمه هارا سمت راست باکس header و نام فایل را در سمت چپ می‌اندازیم. برای جلوه زیبایی، حالت hover دکمه هارا با تغییر رنگ(یک پرده روشن‌تر) همراه می‌کنیم. در گام های بعدی، قسمت back باکس، تکمیل خواهد شد(عملیات های دکمه ها و تغییر نام فایل).

![طراحی باکس header](images/Header.png)

## گام چهارم: طراحی اسلایدبار(ابزار Tools)

در این بخش، با اضافه کردن یک نام(Tools) در بالای باکس و اشکال به صورت عمودی در زیر آن(توجه شود که برای هر شکل، یک کلاس مجزا برای مقداردهی ابعاد اضافه می‌کنیم)، کار را به اتمام می‌رسانیم. تمامی استایل ها، در فایل slidebar.css قرار خواهند داشت. به منظور زیبایی بیشتر، دو شکل جدید(بیضی و متوازی‌الاضلاع) نیز به ابزار اضافه شده اند و با بردن ماوس بر روی هر شکل، ابعاد شکل با استفاده از transition ۰.۲ ثانیه‌ای، کمی بزرگتر خواهد شد(هر بعد، به اندازه ۵ پیکسل).

## گام پنجم: افزودن پارامتر های counter box

در این بخش، نیاز است تمامی اشکالی که در Tools داشتیم را به همراه یک شمارنده در کنار آن، اضافه کنیم. هر کدام از اعداد، نمایش‌گر تعداد اشکال استفاده شده خواهد بود(و طبعا در ابتدا برابر با ۰ هستند). برای این کار، یک div با کلاس counter-shapes-row خواهیم ساخت تا با دادن استایل مناسب، تمامی پارامتر های موجود را در کنار هم(به صورت افقی) قرار دهیم. سپس، برای هر شکل، یک div با کلاس counter-shape-item خواهیم ساخت تا داخل هر کدام، ظاهر شکل به همراه شمارنده آن‌را قرار دهیم(برای ایجاد یک‌دستی باکس). گپ ای بین counter-shape-item ها نیز قرار می‌دهیم تا فواصل آن‌ها متناسب با عرض خود باکس اصلی، رعایت شود. برای جلوه ظاهری نیز، با بردن ماوس بر روی هر کدام از اشکال، ابعاد آن شکل کمی بزرگتر خواهد شد(مشابه Tools). نمایی از counter box را می‌توان در شکل زیر، مشاهده کرد:

![طراحی باکس counter](images/counter.png)

با انجام گام های بالا، فاز front این تمرین به اتمام می‌رسد و باید، عملیات های مورد نظر را پیاده سازی بکنیم که شامل پنج بخش هستند:

- آپدیت شدن شمارنده ها
- عملیات دکمه های header
- تغییر نام فایل
- بردن اشکال از Tools به canvas
- حذف اشکال داخل canvas با دوبار کلیک بر روی آن‌ها

## بک‌اند

در گام اول فاز بک‌اند، می‌خواهیم قابلیت انتخاب، کشیدن و انداختن اشکال بر روی بورد canvas را پیاده‌سازی بکنیم. برای این کار، اول از هرچیز، باید توجه داشت که انتخاب شکل، از Tools شروع می‌شود. چون قرار است شکل را drag کنیم، نیاز است تا در پارامتر های div ای که شکل دایره در آن قرار دارد، چند مورد را اضافه کنیم، اول از همه، قابلیت draggable بودن را باید بعد از کلاس بیان شده برای آن، اضافه کنیم. این قابلیت، به شکل این اجازه را می‌دهد تا بتوان آن را drag کرد، البته باید در نظر داشت که با drag کردن آن، باید تابعی به منظور اجرای عملیات جابه‌جایی، اجرا شود، لذا از

```
onDragStart={(e) => onDragStart(e, 'circle')}
```

کمک می‌گیریم، با اضافه کردن این قابلیت(بعد از فیچر draggable)، قابلیت event handler را اضافه می‌کنیم، در واقع با drag کردن، این تابع اجرا می‌شود. توجه داشته باشید که این تابع به صورت inline به div داده می‌شود و دو ورودی برای تابع onDragStart نیز در آن قرار خواهد داشت، یکی e که بیانگر شی است(اطلاعات ماوس و ... را در خود دارد) و دیگری تایپ شکل، فرضا circle, square و .... این کار به منظور انتقال خود شکل انجام می‌شود.

در قسمت بعدی، در فایل canvas، تغییرات مورد نیاز را پیاده سازی می‌کنیم. پیش از هر چیزی، در ورودی Canvas، دو موجودیت را نیاز است اضافه کنیم، یکی shapes(که بیانگر اشکال کشیده شده تا الان بر روی بوم است و از App آمده است) و دیگری onDropShape(که اصل آن در ادامه بیان شده است و به منظور افزودن شکل به اشکال موجود در بوم اضافه شده است). یک هندلر برای Drop شدن اشکال نیاز داریم و نام آن‌را handleDrop می‌گذاریم. محتوای این تابع هندلر، اول از همه، تایپ شکل را می‌گیرد(با استفاده از getData و گرفتن اطلاعات از e که به آن پاس داده شده است). سایر موارد، ماننند مختصات و ... را نیز بازیابی می‌کنیم. در نهایت، در صورتی که تایپ به دست آمده خالی نبود(در واقع، واقعا شکلی در حال اضافه شدن بود)، تابع onDropShape به منظور افزودن، اجرا می‌شود(این تابع را پیش‌تر بیان کرده بودیم). تابع handleDragOver نیز به منظور جلوگیری از عملیات پیش‌فرض مرورگر بوده تا خود ما drop را کنترل کنیم. در آخر نیز داخل بخش return، هر شکل را به صورت یک div از شکل با تایپ مشخص و به همراه مختصات‌اش، می‌سازیم.

در نهایت نیز، داخل parent اصلی، با کمک دو هندلر، عملیات گرفتن تایپ اشکال و انداختن آن‌ها در برنامه(اشکال اصلی که پیش‌تر بیان کرده بودیم) را انجام می‌دهیم.

## آپدیت شدن تعداد اشکال

در این قسمت، کار ما ساده است، کافیست در والد اصلی، یعنی App.js، یک متغیر تغیر بکنیم که تعداد هر یک از اشکال را در خود ذخیره کرده باشد. سپس، با پاس دادن این متغیر به Counter(فایلی که حاوی باکس counter بود) و استفاده از متغیر های نظیر به جای عدد تعریفی هر شکل(که در ابتدا به صورت پیش‌فرض برابر با ۰ تعریف کرده بودیم)، عملیات آپدیت شدن اشکال را انجام دهیم. متغیری که برای ذخیره سازی نیاز است را در App با نام shapeCounts می‌سازیم و با افزودن تایپ هر کدام از اشکال و شمارش تعداد آن‌ها(با استفاده از فرمول زیر)، تعداد را می‌توانیم داشته باشیم:

```
shapes.filter(s => s.type === 'circle').length
```

به عنوان مثال، در کد بالا، تعداد اشکال دایره ذخیره می‌شود که در ابتدای کار، برابر با ۰ است(چرا که شکلی در صفحه یا همان بوم، نداریم). برای سایر اشکال نیز، همین کد را اضافه می‌کنیم. در نهایت، با پاس دادن این متغیر به <Counter /> و ایمپورت کردن آن در فایل Counter.js و استفاده از متغیر های داخلی‌اش(مانند counts.circle)، می‌توانیم تعداد دایره هارا داشته باشیم. کافیست این مقدار را به جای 0 که در span داخل div دایره ها قرار دارد، جایگذاری کنیم. در نتیجه، این بخش نیز به اتمام می‌رسد. نمونه ای از خروجی را می‌توانید در تصویر زیر، مشاهده کنید(که تعداد اشکال متناسب با رقم کنار شکل در counter box است).

![نمونه ای از تعداد اشکال](images/counter_sample.png)

## حذف یک شکل

برای عملیات حذف یک شکل، می‌خواهیم با دو بار کلیک بر روی آن، شکل از بین برود. این کار را به سادگی می‌توان انجام داد، بدین صورت که مجدد در والد تمامی اشکال، یعنی App.js، یک هندلر جدید برای دوبار کلیک بر روی شکل قرار می‌دهیم به نام handleRemoveShape. سپس این هندلر را در ورودی های Canvas، به فایل بوم پاس می‌دهیم و با ایجاد یک event جدید(onDoubleClick)، بیان می‌کنیم که در صورت دوبار کلیک بر روی یک شکل از canvas، این هندلر اجرا شود و شکل حذف بشود. در ابتدا، برای کد این بخش، از هندلر زیر استفاده کردم که در نگاه اول، درست خواهد بود:

```
setShapes(shapes.filter((s, i) => i !== index));
```

اما با اجرا، یک باگ مهم را شامل می‌شود، آن هم این است که اگر فرضا اولین شکل اضافه شده در آرایه را حذف کنیم، سایر اشکال شیفت خورده و با حفظ ظاهر، مختصاتشان به شکل قبل از خودشان، تبدیل می‌شود. برای رفع این مشکل، کافیست برای هر شکل، یک آیدی به هنگام ثبت نام درست کنیم و سپس موقع حذف، از روی آیدی، شکل را حذف کنیم، در این صورت، مشکل برطرف خواهد شد و اشکال باقی مانده، شیفت نخواهند خورد. ساخت آیدی در این قسمت از پروژه اضافه شده است و در نتیجه، کمی کد های بخش های قبلی، تغییرات جزئی داشتند.

## تغییر نام فایل

در این بخش، به پیاده‌سازی تغییر نام فایل اجرایی خواهیم پرداخت. بدین منظور، عملیاتی که قرار است انجام دهیم، بدین شکل است که با کلیک بر روی نام فایل(که در بالای ثفحه، در بخش header نمایش داده شده است)، باکس Entry ای باز شده و نام جدید را در آن یادداشت کنیم. سپس با زدن enter(و یا کلیک بر روی قسمت های دیگر صفحه)، نام جدید ثبت شود. ساده‌ترین نوع پیاده سازی این بخش، می‌تواند چنین روشی باشد.

حال برای پیاده سازی، در ابتدا، باید نام فایل را در قالب یک متغیر و در والد اصلی، ذخیره داشته باشیم. این نام را در متغیری به اسم filename ذخیره می‌کنیم که یک متد به نام setFileName داشته و به منظور اعمال تغییر در نام فایل، استفاده می‌شود. در نهایت، به ورودی های <Header />، این دو متغیر را پاس خواهیم داد، به شکل زیر:

```
<Header fileName={fileName} setFileName={setFileName}/>
```

حال در خود فایل Header، عملیات اصلی را انجام می‌دهیم. در نظر داشته باشید که برای انجام عملیات، دو وضعیت داریم، یکی آنکه در حال تغییر باشیم و دیگری آنکه بخواهیم اقدام به تغییر بکنیم. در نتیجه، به یک متغیر boolean نیاز داریم تا مشخص بکنیم که در حال ادیت هستیم یا خیر. این متغیر را isEditing در نظر می‌گیریم و در فایل Header قرار می‌دهیم. همچنین یک متد به نام setIsEditing نیز نیاز داریم تا بتواند toggle کند. بعد از این متغیر نیز، به منظور focus خودکار بر روی entrybox، کدی از هوش‌مصنوعی گرفته شد و داخل فایل، قرار داده شد، بدین هدف که قسمت اجباری ای نبود و صرفا برای زیبایی کار، انجام شد.

در ادامه، یک هندلر نیاز داریم به منظور زمانی که Enter زده شده و تغییرات باید ثبت شوند، در این هندلر، باید نام جدید فایل، جایگزین شده و مقدار boolean مربوط به isEditing، تغییر پیدا کند. این هندلر، handleFinishEdit نام دارد.

در نهایت نیز به منظور باز شدن باکس تغییرات، یک هندلر دیگر به صورت inline در همان span ای که نام فایل را نمایش می‌دهد، قرار می‌دهیم، به طوری که با کلیک، متغیر isEditing، تغییر پیدا کند(بیان کردیم که برای تغییر، متغیر setIsEditing را خواهیم داشت). سایر موارد نیز، برای تعریف باکس بوده که در صورت isEditing == True نمایش داده می‌شود، مقدار پیشفرض آن، نام فعلی فایل بوده، فوکوس بر روی Entry است و با زدن Enter، پایان می‌یابد. توجه داشته باشید که در تمامی این موارد، در حالتی که نام خالی برای فایل انتخاب بکنیم، به صورت پیش‌فرض، یک نام Untitled را برای نام فایل، جایگذاری می‌کنیم، چرا که این نام، نمی‌تواند خالی بماند(دقیقا مشابه نام فایل حقیقی در فضای کامپیوتر). در نهایت نیز استایل های ساده ای به این باکس خواهیم داد.
